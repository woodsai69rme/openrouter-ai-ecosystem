#!/usr/bin/env python3
"""
HackRF Penetration Testing Suite
Comprehensive RF security assessment and testing platform
FOR AUTHORIZED PENETRATION TESTING ONLY
"""

import os
import sys
import time
import json
import numpy as np
import threading
import subprocess
from datetime import datetime
from pathlib import Path
import logging
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from scipy import signal
from scipy.fft import fft, fftfreq
import struct

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class RFProtocolAnalyzer:
    """Advanced RF protocol analysis and decoding"""
    
    def __init__(self):
        self.protocols = {
            'wifi_802_11': {
                'name': 'WiFi 802.11',
                'frequency_ranges': [(2400e6, 2485e6), (5150e6, 5850e6)],
                'modulation': 'OFDM/DSSS',
                'description': 'WiFi network analysis and assessment',
                'methods': ['beacon_analysis', 'handshake_capture', 'deauth_detection']
            },
            'bluetooth': {
                'name': 'Bluetooth',
                'frequency_ranges': [(2400e6, 2485e6)],
                'modulation': 'FHSS',
                'description': 'Bluetooth device discovery and analysis',
                'methods': ['device_discovery', 'pairing_analysis', 'data_extraction']
            },
            'zigbee': {
                'name': 'ZigBee',
                'frequency_ranges': [(2405e6, 2480e6), (902e6, 928e6)],
                'modulation': 'DSSS',
                'description': 'ZigBee IoT device assessment',
                'methods': ['network_mapping', 'key_extraction', 'command_injection']
            },
            'lora': {
                'name': 'LoRa',
                'frequency_ranges': [(433e6, 434e6), (863e6, 870e6), (902e6, 928e6)],
                'modulation': 'CSS',
                'description': 'LoRa/LoRaWAN security assessment',
                'methods': ['packet_capture', 'key_analysis', 'replay_attacks']
            },
            'gsm': {
                'name': 'GSM',
                'frequency_ranges': [(850e6, 894e6), (925e6, 960e6), (1710e6, 1785e6), (1805e6, 1880e6)],
                'modulation': 'GMSK',
                'description': 'GSM network analysis (passive only)',
                'methods': ['cell_identification', 'signal_analysis', 'encryption_assessment']
            },
            'rfid_125khz': {
                'name': 'RFID 125kHz',
                'frequency_ranges': [(125e3, 134e3)],
                'modulation': 'ASK',
                'description': 'Low frequency RFID assessment',
                'methods': ['card_reading', 'cloning_detection', 'access_analysis']
            },
            'rfid_13_56mhz': {
                'name': 'RFID 13.56MHz',
                'frequency_ranges': [(13.56e6, 13.56e6)],
                'modulation': 'ASK',
                'description': 'HF RFID/NFC assessment',
                'methods': ['nfc_analysis', 'mifare_testing', 'payment_security']
            },
            'rfid_uhf': {
                'name': 'RFID UHF',
                'frequency_ranges': [(860e6, 960e6)],
                'modulation': 'ASK/PSK',
                'description': 'UHF RFID security testing',
                'methods': ['tag_enumeration', 'password_testing', 'kill_command_analysis']
            },
            'satellite': {
                'name': 'Satellite',
                'frequency_ranges': [(1530e6, 1559e6), (1626.5e6, 1660.5e6)],
                'modulation': 'Various',
                'description': 'Satellite communication analysis',
                'methods': ['signal_identification', 'protocol_analysis', 'security_assessment']
            },
            'ism_433': {
                'name': 'ISM 433MHz',
                'frequency_ranges': [(433.05e6, 434.79e6)],
                'modulation': 'ASK/FSK/PSK',
                'description': 'ISM band device assessment',
                'methods': ['device_identification', 'signal_replay', 'jamming_test']
            },
            'ism_915': {
                'name': 'ISM 915MHz',
                'frequency_ranges': [(902e6, 928e6)],
                'modulation': 'ASK/FSK/PSK',
                'description': 'ISM band security testing',
                'methods': ['protocol_analysis', 'vulnerability_scan', 'exploitation']
            }
        }
        
        self.decoders = {
            'ook_ask': self.decode_ook_ask,
            'fsk': self.decode_fsk,
            'psk': self.decode_psk,
            'manchester': self.decode_manchester,
            'differential': self.decode_differential
        }
        
    def analyze_protocol(self, samples, protocol_type, sample_rate):
        """Analyze samples for specific protocol"""
        if protocol_type not in self.protocols:
            return None
            
        protocol = self.protocols[protocol_type]
        logger.info(f"Analyzing {protocol['name']} protocol")
        
        analysis = {
            'protocol': protocol_type,
            'detected_signals': [],
            'decoded_data': [],
            'security_findings': [],
            'vulnerabilities': []
        }
        
        # Protocol-specific analysis
        if protocol_type == 'wifi_802_11':
            analysis.update(self._analyze_wifi(samples, sample_rate))
        elif protocol_type == 'bluetooth':
            analysis.update(self._analyze_bluetooth(samples, sample_rate))
        elif protocol_type == 'zigbee':
            analysis.update(self._analyze_zigbee(samples, sample_rate))
        elif protocol_type.startswith('rfid'):
            analysis.update(self._analyze_rfid(samples, sample_rate, protocol_type))
        elif protocol_type in ['ism_433', 'ism_915']:
            analysis.update(self._analyze_ism(samples, sample_rate))
            
        return analysis
        
    def _analyze_wifi(self, samples, sample_rate):
        """WiFi 802.11 specific analysis"""
        analysis = {
            'detected_networks': [],
            'security_assessment': {},
            'vulnerabilities': []
        }
        
        # Simulate WiFi analysis
        # In real implementation, this would use gr-ieee802-11 or similar
        analysis['detected_networks'] = [
            {
                'ssid': 'TestNetwork_WEP',
                'bssid': '00:11:22:33:44:55',
                'security': 'WEP',
                'channel': 6,
                'signal_strength': -45,
                'vulnerability': 'WEP encryption is broken'
            },
            {
                'ssid': 'TestNetwork_WPA2',
                'bssid': '00:11:22:33:44:66',
                'security': 'WPA2-PSK',
                'channel': 11,
                'signal_strength': -52,
                'vulnerability': 'Weak password suspected'
            }
        ]
        
        analysis['vulnerabilities'] = [
            'WEP encryption detected (easily crackable)',
            'WPS enabled on some networks',
            'Weak WPA2 passwords detected'
        ]
        
        return analysis
        
    def _analyze_bluetooth(self, samples, sample_rate):
        """Bluetooth specific analysis"""
        analysis = {
            'discovered_devices': [],
            'pairing_info': [],
            'security_issues': []
        }
        
        # Simulate Bluetooth analysis
        analysis['discovered_devices'] = [
            {
                'address': '00:1A:2B:3C:4D:5E',
                'name': 'Samsung Galaxy',
                'class': 'Smartphone',
                'services': ['Audio', 'HID'],
                'security': 'SSP enabled'
            },
            {
                'address': '00:1A:2B:3C:4D:5F',
                'name': 'Unknown Device',
                'class': 'IoT Device',
                'services': ['Custom'],
                'security': 'Legacy pairing'
            }
        ]
        
        analysis['security_issues'] = [
            'Legacy pairing modes detected',
            'Unencrypted services available',
            'Default PIN usage suspected'
        ]
        
        return analysis
        
    def _analyze_zigbee(self, samples, sample_rate):
        """ZigBee specific analysis"""
        analysis = {
            'networks': [],
            'devices': [],
            'security_status': {}
        }
        
        # Simulate ZigBee analysis
        analysis['networks'] = [
            {
                'pan_id': '0x1234',
                'channel': 11,
                'coordinator': '0x0000',
                'security': 'AES-128 enabled',
                'key_transport': 'Insecure'
            }
        ]
        
        analysis['devices'] = [
            {
                'short_addr': '0x0001',
                'ieee_addr': '0x001234567890ABCD',
                'type': 'Router',
                'manufacturer': 'Philips',
                'model': 'Hue Bulb'
            }
        ]
        
        return analysis
        
    def _analyze_rfid(self, samples, sample_rate, rfid_type):
        """RFID specific analysis"""
        analysis = {
            'detected_cards': [],
            'protocols': [],
            'security_assessment': {}
        }
        
        if rfid_type == 'rfid_13_56mhz':
            analysis['detected_cards'] = [
                {
                    'uid': '04:12:34:56:78:90:AB',
                    'type': 'MIFARE Classic 1K',
                    'sector_security': 'Default keys detected',
                    'vulnerability': 'Crypto1 cipher broken'
                }
            ]
            
        elif rfid_type == 'rfid_uhf':
            analysis['detected_cards'] = [
                {
                    'epc': '3000123456789012345678901234',
                    'protocol': 'EPC Class 1 Gen 2',
                    'security': 'No password protection',
                    'vulnerability': 'Read/write access available'
                }
            ]
            
        return analysis
        
    def _analyze_ism(self, samples, sample_rate):
        """ISM band analysis"""
        analysis = {
            'detected_devices': [],
            'protocols': [],
            'replay_candidates': []
        }
        
        # Simulate ISM device detection
        analysis['detected_devices'] = [
            {
                'frequency': 433.92e6,
                'modulation': 'ASK',
                'protocol': 'Rolling code remote',
                'security': 'Fixed code detected',
                'vulnerability': 'Replay attack possible'
            },
            {
                'frequency': 315e6,
                'modulation': 'FSK',
                'protocol': 'Tire pressure sensor',
                'security': 'No encryption',
                'vulnerability': 'Spoofing possible'
            }
        ]
        
        return analysis
        
    def decode_ook_ask(self, samples):
        """Decode OOK/ASK modulated signals"""
        # Envelope detection
        envelope = np.abs(samples)
        
        # Simple threshold detection
        threshold = np.mean(envelope) + np.std(envelope)
        bits = envelope > threshold
        
        # Find bit transitions
        transitions = np.diff(bits.astype(int))
        
        return {
            'modulation': 'OOK/ASK',
            'bits_detected': len(bits),
            'threshold': threshold,
            'decoded_bits': bits[:100].tolist()  # First 100 bits
        }
        
    def decode_fsk(self, samples):
        """Decode FSK modulated signals"""
        # Frequency analysis
        freqs = np.fft.fftfreq(len(samples))
        fft_data = np.fft.fft(samples)
        
        # Find dominant frequencies
        magnitude = np.abs(fft_data)
        peaks = signal.find_peaks(magnitude, height=np.max(magnitude) * 0.5)[0]
        
        return {
            'modulation': 'FSK',
            'dominant_frequencies': freqs[peaks].tolist(),
            'frequency_separation': 'Estimated based on peaks'
        }
        
    def decode_psk(self, samples):
        """Decode PSK modulated signals"""
        # Phase analysis
        phase = np.angle(samples)
        phase_diff = np.diff(phase)
        
        # Detect phase transitions
        threshold = np.pi / 2
        transitions = np.abs(phase_diff) > threshold
        
        return {
            'modulation': 'PSK',
            'phase_transitions': np.sum(transitions),
            'constellation_points': 'Analysis required'
        }
        
    def decode_manchester(self, samples):
        """Decode Manchester encoded signals"""
        # Convert to bits first
        envelope = np.abs(samples)
        threshold = np.mean(envelope)
        raw_bits = envelope > threshold
        
        # Manchester decoding (simplified)
        decoded_bits = []
        for i in range(0, len(raw_bits) - 1, 2):
            if raw_bits[i] != raw_bits[i + 1]:
                decoded_bits.append(raw_bits[i])
                
        return {
            'encoding': 'Manchester',
            'raw_bits': len(raw_bits),
            'decoded_bits': decoded_bits[:50]  # First 50 bits
        }
        
    def decode_differential(self, samples):
        """Decode differential encoded signals"""
        phase = np.angle(samples)
        phase_diff = np.diff(phase)
        
        # Differential decoding
        bits = phase_diff > 0
        
        return {
            'encoding': 'Differential',
            'phase_changes': len(phase_diff),
            'decoded_bits': bits[:100].tolist()
        }

class RFInjectionEngine:
    """RF signal injection and replay capabilities"""
    
    def __init__(self, hackrf_controller):
        self.hackrf = hackrf_controller
        self.replay_buffer = []
        self.injection_patterns = {}
        
    def capture_signal(self, duration=5.0, frequency=433.92e6):
        """Capture signal for later replay"""
        logger.info(f"Capturing signal at {frequency/1e6:.2f} MHz for {duration}s")
        
        self.hackrf.set_frequency(frequency)
        
        capture_data = {
            'frequency': frequency,
            'duration': duration,
            'timestamp': datetime.now().isoformat(),
            'samples': [],
            'metadata': {
                'sample_rate': self.hackrf.sample_rate,
                'gain': self.hackrf.gain
            }
        }
        
        # Simulate capture (replace with actual HackRF capture)
        num_samples = int(duration * self.hackrf.sample_rate)
        
        # Generate sample data (in real implementation, this comes from HackRF)
        t = np.linspace(0, duration, num_samples)
        carrier = np.exp(1j * 2 * np.pi * frequency * t)
        noise = np.random.normal(0, 0.1, num_samples) + 1j * np.random.normal(0, 0.1, num_samples)
        
        # Add some signal patterns
        if frequency == 433.92e6:
            # Simulate remote control signal
            pattern = np.repeat([1, 0, 1, 1, 0, 1, 0, 0], int(num_samples / 64))
            modulated = pattern[:num_samples] * carrier + noise
        else:
            modulated = noise
            
        capture_data['samples'] = modulated.tolist()[:1000]  # Store first 1000 samples
        
        self.replay_buffer.append(capture_data)
        logger.info(f"Signal captured and stored (buffer size: {len(self.replay_buffer)})")
        
        return capture_data
        
    def replay_signal(self, capture_index, repeat_count=1):
        """Replay captured signal"""
        if capture_index >= len(self.replay_buffer):
            logger.error("Invalid capture index")
            return False
            
        capture = self.replay_buffer[capture_index]
        logger.info(f"Replaying signal at {capture['frequency']/1e6:.2f} MHz ({repeat_count} times)")
        
        # Set HackRF to transmit mode
        self.hackrf.set_frequency(capture['frequency'])
        
        # In real implementation, this would transmit the samples
        for i in range(repeat_count):
            logger.info(f"Replay {i+1}/{repeat_count}")
            time.sleep(0.1)  # Simulate transmission time
            
        logger.info("Replay completed")
        return True
        
    def generate_jamming_signal(self, target_frequency, bandwidth=1e6, power_level=1.0):
        """Generate jamming signal for testing"""
        logger.warning("Generating jamming signal - USE ONLY FOR AUTHORIZED TESTING")
        
        jamming_config = {
            'type': 'broadband_noise',
            'frequency': target_frequency,
            'bandwidth': bandwidth,
            'power': power_level,
            'timestamp': datetime.now().isoformat()
        }
        
        # Generate noise signal
        duration = 1.0  # 1 second
        num_samples = int(duration * self.hackrf.sample_rate)
        
        # Wideband noise
        noise_i = np.random.normal(0, power_level, num_samples)
        noise_q = np.random.normal(0, power_level, num_samples)
        jamming_signal = noise_i + 1j * noise_q
        
        jamming_config['samples'] = jamming_signal.tolist()[:100]  # Store sample
        
        return jamming_config
        
    def test_frequency_hopping(self, frequencies, dwell_time=0.1):
        """Test frequency hopping patterns"""
        logger.info(f"Testing frequency hopping across {len(frequencies)} frequencies")
        
        hopping_log = []
        
        for freq in frequencies:
            hop_entry = {
                'frequency': freq,
                'timestamp': datetime.now().isoformat(),
                'dwell_time': dwell_time
            }
            
            self.hackrf.set_frequency(freq)
            time.sleep(dwell_time)
            
            hopping_log.append(hop_entry)
            logger.info(f"Hopped to {freq/1e6:.2f} MHz")
            
        return hopping_log
        
    def analyze_timing_attacks(self, signal_data):
        """Analyze timing-based vulnerabilities"""
        timing_analysis = {
            'packet_intervals': [],
            'timing_patterns': [],
            'vulnerabilities': []
        }
        
        # Simulate timing analysis
        # In real implementation, this would analyze actual packet timing
        intervals = np.random.exponential(0.1, 100)  # Random intervals
        timing_analysis['packet_intervals'] = intervals.tolist()
        
        # Look for patterns
        if np.std(intervals) < 0.05:
            timing_analysis['vulnerabilities'].append('Fixed timing detected - predictable transmission')
            
        return timing_analysis

class WirelessSecurityAssessment:
    """Comprehensive wireless security assessment tools"""
    
    def __init__(self, hackrf_controller):
        self.hackrf = hackrf_controller
        self.assessment_results = {}
        
    def assess_wifi_security(self, target_networks=None):
        """Comprehensive WiFi security assessment"""
        logger.info("Starting WiFi security assessment")
        
        assessment = {
            'scan_timestamp': datetime.now().isoformat(),
            'networks_found': [],
            'security_issues': [],
            'recommendations': []
        }
        
        # Simulate WiFi assessment
        networks = [
            {
                'ssid': 'CorporateWiFi',
                'bssid': '00:11:22:33:44:55',
                'security': 'WPA2-Enterprise',
                'encryption': 'AES',
                'signal_strength': -45,
                'channel': 6,
                'wps_enabled': False,
                'hidden': False,
                'vulnerabilities': []
            },
            {
                'ssid': 'GuestNetwork',
                'bssid': '00:11:22:33:44:56',
                'security': 'Open',
                'encryption': 'None',
                'signal_strength': -52,
                'channel': 11,
                'wps_enabled': False,
                'hidden': False,
                'vulnerabilities': ['Open network', 'No encryption']
            },
            {
                'ssid': 'OldRouter',
                'bssid': '00:11:22:33:44:57',
                'security': 'WEP',
                'encryption': 'WEP',
                'signal_strength': -38,
                'channel': 1,
                'wps_enabled': True,
                'hidden': False,
                'vulnerabilities': ['WEP encryption', 'WPS enabled', 'Outdated security']
            }
        ]
        
        for network in networks:
            assessment['networks_found'].append(network)
            
            # Assess vulnerabilities
            if network['security'] == 'Open':
                assessment['security_issues'].append(f"Open network detected: {network['ssid']}")
            elif network['security'] == 'WEP':
                assessment['security_issues'].append(f"WEP encryption (broken): {network['ssid']}")
            elif network['wps_enabled']:
                assessment['security_issues'].append(f"WPS enabled: {network['ssid']}")
                
        # Generate recommendations
        if any('Open' in net['security'] for net in networks):
            assessment['recommendations'].append('Implement WPA3 or WPA2 security on open networks')
        if any('WEP' in net['security'] for net in networks):
            assessment['recommendations'].append('Upgrade from WEP to WPA3/WPA2 immediately')
        if any(net['wps_enabled'] for net in networks):
            assessment['recommendations'].append('Disable WPS on all access points')
            
        return assessment
        
    def assess_bluetooth_security(self):
        """Bluetooth security assessment"""
        logger.info("Starting Bluetooth security assessment")
        
        assessment = {
            'scan_timestamp': datetime.now().isoformat(),
            'devices_found': [],
            'security_analysis': {},
            'attack_vectors': []
        }
        
        # Simulate Bluetooth device discovery
        devices = [
            {
                'address': '00:1A:2B:3C:4D:5E',
                'name': 'iPhone 12',
                'device_class': 'Smartphone',
                'services': ['Audio Gateway', 'A2DP'],
                'security_mode': 'SSP',
                'pin_required': False,
                'vulnerabilities': []
            },
            {
                'address': '00:1A:2B:3C:4D:5F',
                'name': 'Old Headset',
                'device_class': 'Audio',
                'services': ['Audio Gateway'],
                'security_mode': 'Legacy',
                'pin_required': True,
                'vulnerabilities': ['Legacy pairing', 'Fixed PIN suspected']
            }
        ]
        
        for device in devices:
            assessment['devices_found'].append(device)
            
            if device['security_mode'] == 'Legacy':
                assessment['attack_vectors'].append(f"PIN brute force on {device['name']}")
            if not device['pin_required']:
                assessment['attack_vectors'].append(f"Unauthorized pairing possible with {device['name']}")
                
        return assessment
        
    def assess_iot_security(self, frequency_ranges):
        """IoT device security assessment"""
        logger.info("Starting IoT security assessment")
        
        assessment = {
            'scan_timestamp': datetime.now().isoformat(),
            'frequency_ranges_scanned': frequency_ranges,
            'devices_detected': [],
            'protocols_identified': [],
            'security_findings': []
        }
        
        # Simulate IoT device detection
        iot_devices = [
            {
                'frequency': 433.92e6,
                'protocol': 'Unknown proprietary',
                'device_type': 'Remote control',
                'modulation': 'ASK',
                'encryption': 'None detected',
                'vulnerability': 'Fixed code transmission',
                'risk_level': 'High'
            },
            {
                'frequency': 2.4e9,
                'protocol': 'ZigBee',
                'device_type': 'Smart light bulb',
                'modulation': 'OQPSK',
                'encryption': 'AES-128',
                'vulnerability': 'Default network key',
                'risk_level': 'Medium'
            },
            {
                'frequency': 868e6,
                'protocol': 'LoRa',
                'device_type': 'Sensor node',
                'modulation': 'CSS',
                'encryption': 'AES-128',
                'vulnerability': 'Weak key derivation',
                'risk_level': 'Medium'
            }
        ]
        
        for device in iot_devices:
            assessment['devices_detected'].append(device)
            
            if device['encryption'] == 'None detected':
                assessment['security_findings'].append(f"Unencrypted {device['device_type']} communication")
            if 'default' in device['vulnerability'].lower():
                assessment['security_findings'].append(f"Default credentials on {device['device_type']}")
                
        return assessment
        
    def generate_security_report(self, assessments):
        """Generate comprehensive security report"""
        report = {
            'executive_summary': {},
            'detailed_findings': assessments,
            'risk_matrix': {},
            'recommendations': [],
            'generated_at': datetime.now().isoformat()
        }
        
        # Calculate risk levels
        total_issues = 0
        high_risk = 0
        medium_risk = 0
        low_risk = 0
        
        for assessment_type, data in assessments.items():
            if 'security_issues' in data:
                total_issues += len(data['security_issues'])
            if 'vulnerabilities' in data:
                total_issues += len(data['vulnerabilities'])
                
        # Risk categorization (simplified)
        if total_issues > 10:
            overall_risk = 'High'
        elif total_issues > 5:
            overall_risk = 'Medium'
        else:
            overall_risk = 'Low'
            
        report['executive_summary'] = {
            'overall_risk_level': overall_risk,
            'total_issues_found': total_issues,
            'assessment_types': list(assessments.keys()),
            'urgent_actions_required': total_issues > 5
        }
        
        # Generate recommendations
        if total_issues > 0:
            report['recommendations'] = [
                'Implement network segmentation for IoT devices',
                'Upgrade all devices using WEP encryption',
                'Disable WPS on wireless access points',
                'Regular security audits and penetration testing',
                'Employee security awareness training'
            ]
            
        return report

class HackRFPentestGUI:
    """Enhanced GUI for HackRF penetration testing"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("HackRF Penetration Testing Suite")
        self.root.geometry("1400x900")
        self.root.configure(bg='#0a0a0a')
        
        # Initialize components
        from hackrf_interface import HackRFController  # Import from main interface
        self.hackrf = HackRFController()
        self.protocol_analyzer = RFProtocolAnalyzer()
        self.injection_engine = RFInjectionEngine(self.hackrf)
        self.security_assessor = WirelessSecurityAssessment(self.hackrf)
        
        # Current data
        self.current_analysis = None
        self.assessment_results = {}
        
        self.setup_styles()
        self.create_gui()
        
    def setup_styles(self):
        """Setup dark penetration testing theme"""
        self.style = ttk.Style()
        self.style.theme_use('clam')
        
        # Dark hacker theme
        self.style.configure('Title.TLabel', foreground='#00ff00', background='#0a0a0a', 
                           font=('Courier', 14, 'bold'))
        self.style.configure('Warning.TLabel', foreground='#ff4444', background='#0a0a0a', 
                           font=('Courier', 10, 'bold'))
        self.style.configure('TFrame', background='#0a0a0a')
        self.style.configure('TNotebook', background='#0a0a0a')
        self.style.configure('TNotebook.Tab', background='#1a1a1a', foreground='#00ff00')
        
    def create_gui(self):
        """Create penetration testing GUI"""
        
        # Warning header
        warning_frame = ttk.Frame(self.root)
        warning_frame.pack(fill=tk.X, padx=10, pady=5)
        
        warning_text = "⚠️ AUTHORIZED PENETRATION TESTING ONLY ⚠️\nFor legitimate security assessment purposes only"
        warning_label = ttk.Label(warning_frame, text=warning_text, style='Warning.TLabel')
        warning_label.pack()
        
        # Main title
        title_frame = ttk.Frame(self.root)
        title_frame.pack(fill=tk.X, padx=10, pady=5)
        
        title_label = ttk.Label(title_frame, text="🔍 HackRF Penetration Testing Suite", 
                               style='Title.TLabel')
        title_label.pack(side=tk.LEFT)
        
        # Device status
        status_text = "Device: " + ("✓ Connected" if self.hackrf.device_connected else "✗ Disconnected")
        status_label = ttk.Label(title_frame, text=status_text, 
                               foreground='green' if self.hackrf.device_connected else 'red')
        status_label.pack(side=tk.RIGHT)
        
        # Main notebook
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Create pentesting tabs
        self.create_protocol_analysis_tab()
        self.create_signal_injection_tab()
        self.create_wireless_assessment_tab()
        self.create_vulnerability_scanner_tab()
        self.create_reporting_tab()
        
    def create_protocol_analysis_tab(self):
        """Create protocol analysis tab"""
        protocol_frame = ttk.Frame(self.notebook)
        self.notebook.add(protocol_frame, text="📡 Protocol Analysis")
        
        # Protocol selection
        selection_frame = ttk.LabelFrame(protocol_frame, text="Target Protocol")
        selection_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.protocol_var = tk.StringVar(value='wifi_802_11')
        
        protocols_grid = ttk.Frame(selection_frame)
        protocols_grid.pack(fill=tk.X, padx=5, pady=5)
        
        row = 0
        col = 0
        for protocol_id, protocol_info in self.protocol_analyzer.protocols.items():
            ttk.Radiobutton(protocols_grid, text=f"{protocol_info['name']}\n{protocol_info['description']}", 
                           variable=self.protocol_var, value=protocol_id).grid(row=row, column=col, sticky=tk.W, padx=5, pady=2)
            col += 1
            if col >= 3:
                col = 0
                row += 1
                
        # Analysis controls
        control_frame = ttk.LabelFrame(protocol_frame, text="Analysis Parameters")
        control_frame.pack(fill=tk.X, padx=5, pady=5)
        
        params_grid = ttk.Frame(control_frame)
        params_grid.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(params_grid, text="Center Freq (MHz):").grid(row=0, column=0, padx=5)
        self.center_freq_var = tk.StringVar(value="433.92")
        ttk.Entry(params_grid, textvariable=self.center_freq_var, width=15).grid(row=0, column=1, padx=5)
        
        ttk.Label(params_grid, text="Sample Rate (MHz):").grid(row=0, column=2, padx=5)
        self.sample_rate_var = tk.StringVar(value="2.0")
        ttk.Entry(params_grid, textvariable=self.sample_rate_var, width=15).grid(row=0, column=3, padx=5)
        
        ttk.Label(params_grid, text="Duration (s):").grid(row=0, column=4, padx=5)
        self.duration_var = tk.StringVar(value="10")
        ttk.Entry(params_grid, textvariable=self.duration_var, width=10).grid(row=0, column=5, padx=5)
        
        # Action buttons
        action_frame = ttk.Frame(control_frame)
        action_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(action_frame, text="Start Analysis", command=self.start_protocol_analysis).pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="Stop Analysis", command=self.stop_analysis).pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="Export Results", command=self.export_protocol_results).pack(side=tk.LEFT, padx=5)
        
        # Results display
        results_frame = ttk.LabelFrame(protocol_frame, text="Analysis Results")
        results_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.protocol_results_text = tk.Text(results_frame, bg='#1a1a1a', fg='#00ff00', 
                                           font=('Courier', 10))
        
        scrollbar_protocol = ttk.Scrollbar(results_frame, orient=tk.VERTICAL, command=self.protocol_results_text.yview)
        self.protocol_results_text.configure(yscrollcommand=scrollbar_protocol.set)
        
        self.protocol_results_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar_protocol.pack(side=tk.RIGHT, fill=tk.Y)
        
    def create_signal_injection_tab(self):
        """Create signal injection and replay tab"""
        injection_frame = ttk.Frame(self.notebook)
        self.notebook.add(injection_frame, text="📡 Signal Injection")
        
        # Capture section
        capture_frame = ttk.LabelFrame(injection_frame, text="Signal Capture")
        capture_frame.pack(fill=tk.X, padx=5, pady=5)
        
        capture_controls = ttk.Frame(capture_frame)
        capture_controls.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(capture_controls, text="Frequency (MHz):").pack(side=tk.LEFT, padx=5)
        self.capture_freq_var = tk.StringVar(value="433.92")
        ttk.Entry(capture_controls, textvariable=self.capture_freq_var, width=15).pack(side=tk.LEFT, padx=5)
        
        ttk.Label(capture_controls, text="Duration (s):").pack(side=tk.LEFT, padx=5)
        self.capture_duration_var = tk.StringVar(value="5")
        ttk.Entry(capture_controls, textvariable=self.capture_duration_var, width=10).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(capture_controls, text="Capture Signal", command=self.capture_signal).pack(side=tk.LEFT, padx=5)
        
        # Replay section
        replay_frame = ttk.LabelFrame(injection_frame, text="Signal Replay")
        replay_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Captured signals list
        signals_list_frame = ttk.Frame(replay_frame)
        signals_list_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(signals_list_frame, text="Captured Signals:").pack(side=tk.LEFT)
        
        self.signals_listbox = tk.Listbox(signals_list_frame, bg='#1a1a1a', fg='#00ff00', height=5)
        self.signals_listbox.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        replay_controls = ttk.Frame(replay_frame)
        replay_controls.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(replay_controls, text="Repeat Count:").pack(side=tk.LEFT, padx=5)
        self.repeat_count_var = tk.StringVar(value="1")
        ttk.Entry(replay_controls, textvariable=self.repeat_count_var, width=10).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(replay_controls, text="Replay Selected", command=self.replay_signal).pack(side=tk.LEFT, padx=5)
        ttk.Button(replay_controls, text="Delete Selected", command=self.delete_capture).pack(side=tk.LEFT, padx=5)
        
        # Advanced injection
        advanced_frame = ttk.LabelFrame(injection_frame, text="Advanced Injection")
        advanced_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        advanced_controls = ttk.Frame(advanced_frame)
        advanced_controls.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(advanced_controls, text="Generate Jamming", command=self.generate_jamming).pack(side=tk.LEFT, padx=5)
        ttk.Button(advanced_controls, text="Frequency Hopping Test", command=self.test_frequency_hopping).pack(side=tk.LEFT, padx=5)
        ttk.Button(advanced_controls, text="Timing Analysis", command=self.analyze_timing).pack(side=tk.LEFT, padx=5)
        
        # Injection log
        self.injection_log = tk.Text(advanced_frame, bg='#1a1a1a', fg='#00ff00', 
                                   font=('Courier', 10), height=10)
        self.injection_log.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
    def create_wireless_assessment_tab(self):
        """Create wireless security assessment tab"""
        assessment_frame = ttk.Frame(self.notebook)
        self.notebook.add(assessment_frame, text="🔐 Security Assessment")
        
        # Assessment type selection
        type_frame = ttk.LabelFrame(assessment_frame, text="Assessment Type")
        type_frame.pack(fill=tk.X, padx=5, pady=5)
        
        assessment_buttons = ttk.Frame(type_frame)
        assessment_buttons.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(assessment_buttons, text="WiFi Security Scan", command=self.assess_wifi).pack(side=tk.LEFT, padx=5)
        ttk.Button(assessment_buttons, text="Bluetooth Assessment", command=self.assess_bluetooth).pack(side=tk.LEFT, padx=5)
        ttk.Button(assessment_buttons, text="IoT Device Scan", command=self.assess_iot).pack(side=tk.LEFT, padx=5)
        ttk.Button(assessment_buttons, text="Full Assessment", command=self.full_assessment).pack(side=tk.LEFT, padx=5)
        
        # Assessment parameters
        params_frame = ttk.LabelFrame(assessment_frame, text="Assessment Parameters")
        params_frame.pack(fill=tk.X, padx=5, pady=5)
        
        params_grid = ttk.Frame(params_frame)
        params_grid.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(params_grid, text="Target Network:").grid(row=0, column=0, padx=5)
        self.target_network_var = tk.StringVar()
        ttk.Entry(params_grid, textvariable=self.target_network_var, width=20).grid(row=0, column=1, padx=5)
        
        ttk.Label(params_grid, text="Scan Depth:").grid(row=0, column=2, padx=5)
        self.scan_depth_var = tk.StringVar(value="Standard")
        depth_combo = ttk.Combobox(params_grid, textvariable=self.scan_depth_var, width=15)
        depth_combo['values'] = ('Quick', 'Standard', 'Deep', 'Comprehensive')
        depth_combo.grid(row=0, column=3, padx=5)
        
        # Assessment results
        results_frame = ttk.LabelFrame(assessment_frame, text="Assessment Results")
        results_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Results tree
        columns = ('Type', 'Target', 'Risk Level', 'Vulnerability', 'Recommendation')
        self.assessment_tree = ttk.Treeview(results_frame, columns=columns, show='headings', height=15)
        
        for col in columns:
            self.assessment_tree.heading(col, text=col)
            self.assessment_tree.column(col, width=120)
            
        scrollbar_assessment = ttk.Scrollbar(results_frame, orient=tk.VERTICAL, command=self.assessment_tree.yview)
        self.assessment_tree.configure(yscrollcommand=scrollbar_assessment.set)
        
        self.assessment_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar_assessment.pack(side=tk.RIGHT, fill=tk.Y)
        
    def create_vulnerability_scanner_tab(self):
        """Create vulnerability scanner tab"""
        vuln_frame = ttk.Frame(self.notebook)
        self.notebook.add(vuln_frame, text="🔍 Vulnerability Scanner")
        
        # Scanner configuration
        config_frame = ttk.LabelFrame(vuln_frame, text="Scanner Configuration")
        config_frame.pack(fill=tk.X, padx=5, pady=5)
        
        config_grid = ttk.Frame(config_frame)
        config_grid.pack(fill=tk.X, padx=5, pady=5)
        
        # Vulnerability types
        vuln_types_frame = ttk.LabelFrame(config_frame, text="Vulnerability Types")
        vuln_types_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.vuln_checks = {
            'weak_encryption': tk.BooleanVar(value=True),
            'default_credentials': tk.BooleanVar(value=True),
            'protocol_flaws': tk.BooleanVar(value=True),
            'timing_attacks': tk.BooleanVar(value=False),
            'replay_attacks': tk.BooleanVar(value=True),
            'jamming_susceptible': tk.BooleanVar(value=False)
        }
        
        row = 0
        col = 0
        for vuln_type, var in self.vuln_checks.items():
            ttk.Checkbutton(vuln_types_frame, text=vuln_type.replace('_', ' ').title(), 
                           variable=var).grid(row=row, column=col, sticky=tk.W, padx=5, pady=2)
            col += 1
            if col >= 3:
                col = 0
                row += 1
                
        # Scanner controls
        controls_frame = ttk.Frame(config_frame)
        controls_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(controls_frame, text="Start Vulnerability Scan", command=self.start_vuln_scan).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Stop Scan", command=self.stop_vuln_scan).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Export Report", command=self.export_vuln_report).pack(side=tk.LEFT, padx=5)
        
        # Progress indicator
        self.vuln_progress = ttk.Progressbar(vuln_frame, mode='indeterminate')
        self.vuln_progress.pack(fill=tk.X, padx=5, pady=2)
        
        # Vulnerability results
        vuln_results_frame = ttk.LabelFrame(vuln_frame, text="Discovered Vulnerabilities")
        vuln_results_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Vulnerability tree
        vuln_columns = ('Severity', 'Target', 'Vulnerability', 'CVSS', 'Exploit', 'Mitigation')
        self.vuln_tree = ttk.Treeview(vuln_results_frame, columns=vuln_columns, show='headings', height=12)
        
        for col in vuln_columns:
            self.vuln_tree.heading(col, text=col)
            if col == 'Vulnerability':
                self.vuln_tree.column(col, width=200)
            else:
                self.vuln_tree.column(col, width=100)
                
        scrollbar_vuln = ttk.Scrollbar(vuln_results_frame, orient=tk.VERTICAL, command=self.vuln_tree.yview)
        self.vuln_tree.configure(yscrollcommand=scrollbar_vuln.set)
        
        self.vuln_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar_vuln.pack(side=tk.RIGHT, fill=tk.Y)
        
    def create_reporting_tab(self):
        """Create reporting and documentation tab"""
        reporting_frame = ttk.Frame(self.notebook)
        self.notebook.add(reporting_frame, text="📊 Reporting")
        
        # Report generation
        gen_frame = ttk.LabelFrame(reporting_frame, text="Report Generation")
        gen_frame.pack(fill=tk.X, padx=5, pady=5)
        
        gen_buttons = ttk.Frame(gen_frame)
        gen_buttons.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(gen_buttons, text="Generate Executive Summary", command=self.generate_executive_summary).pack(side=tk.LEFT, padx=5)
        ttk.Button(gen_buttons, text="Technical Report", command=self.generate_technical_report).pack(side=tk.LEFT, padx=5)
        ttk.Button(gen_buttons, text="Compliance Report", command=self.generate_compliance_report).pack(side=tk.LEFT, padx=5)
        ttk.Button(gen_buttons, text="Export All Data", command=self.export_all_data).pack(side=tk.LEFT, padx=5)
        
        # Report template selection
        template_frame = ttk.LabelFrame(reporting_frame, text="Report Template")
        template_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.report_template_var = tk.StringVar(value="standard")
        templates = [
            ("Standard Pentest Report", "standard"),
            ("Executive Summary", "executive"),
            ("Technical Deep Dive", "technical"),
            ("Compliance Assessment", "compliance"),
            ("Custom Template", "custom")
        ]
        
        for text, value in templates:
            ttk.Radiobutton(template_frame, text=text, variable=self.report_template_var, value=value).pack(anchor=tk.W, padx=5)
            
        # Report preview
        preview_frame = ttk.LabelFrame(reporting_frame, text="Report Preview")
        preview_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.report_preview = tk.Text(preview_frame, bg='#1a1a1a', fg='#00ff00', 
                                     font=('Courier', 10))
        
        scrollbar_report = ttk.Scrollbar(preview_frame, orient=tk.VERTICAL, command=self.report_preview.yview)
        self.report_preview.configure(yscrollcommand=scrollbar_report.set)
        
        self.report_preview.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar_report.pack(side=tk.RIGHT, fill=tk.Y)
        
    # Event handlers for penetration testing functions
    def start_protocol_analysis(self):
        """Start protocol analysis"""
        protocol = self.protocol_var.get()
        freq = float(self.center_freq_var.get()) * 1e6
        duration = float(self.duration_var.get())
        
        self.protocol_results_text.insert(tk.END, f"\n[{datetime.now().strftime('%H:%M:%S')}] Starting {protocol} analysis at {freq/1e6:.2f} MHz\n")
        self.protocol_results_text.see(tk.END)
        
        # Run analysis in background thread
        analysis_thread = threading.Thread(target=self._protocol_analysis_thread, args=(protocol, freq, duration))
        analysis_thread.daemon = True
        analysis_thread.start()
        
    def _protocol_analysis_thread(self, protocol, frequency, duration):
        """Background protocol analysis"""
        try:
            # Simulate sample collection
            sample_rate = float(self.sample_rate_var.get()) * 1e6
            num_samples = int(duration * sample_rate)
            
            # Generate simulated samples
            t = np.linspace(0, duration, num_samples)
            samples = np.random.normal(0, 0.1, num_samples) + 1j * np.random.normal(0, 0.1, num_samples)
            
            # Analyze protocol
            analysis = self.protocol_analyzer.analyze_protocol(samples, protocol, sample_rate)
            
            # Update GUI
            self.root.after(0, self._update_protocol_results, analysis)
            
        except Exception as e:
            logger.error(f"Protocol analysis error: {e}")
            
    def _update_protocol_results(self, analysis):
        """Update protocol analysis results"""
        if not analysis:
            return
            
        result_text = f"""
PROTOCOL ANALYSIS RESULTS
{'='*50}
Protocol: {analysis['protocol']}
Timestamp: {datetime.now().isoformat()}

DETECTED SIGNALS: {len(analysis['detected_signals'])}
DECODED DATA: {len(analysis['decoded_data'])}
SECURITY FINDINGS: {len(analysis['security_findings'])}
VULNERABILITIES: {len(analysis['vulnerabilities'])}

"""
        
        # Add specific findings
        for vuln in analysis['vulnerabilities']:
            result_text += f"[VULNERABILITY] {vuln}\n"
            
        for finding in analysis['security_findings']:
            result_text += f"[SECURITY] {finding}\n"
            
        self.protocol_results_text.insert(tk.END, result_text)
        self.protocol_results_text.see(tk.END)
        
    def capture_signal(self):
        """Capture signal for replay"""
        try:
            freq = float(self.capture_freq_var.get()) * 1e6
            duration = float(self.capture_duration_var.get())
            
            capture_data = self.injection_engine.capture_signal(duration, freq)
            
            # Add to signals list
            capture_name = f"{freq/1e6:.2f}MHz_{datetime.now().strftime('%H%M%S')}"
            self.signals_listbox.insert(tk.END, capture_name)
            
            self.injection_log.insert(tk.END, f"[{datetime.now().strftime('%H:%M:%S')}] Signal captured: {capture_name}\n")
            self.injection_log.see(tk.END)
            
        except Exception as e:
            messagebox.showerror("Error", f"Capture failed: {str(e)}")
            
    def replay_signal(self):
        """Replay selected signal"""
        selection = self.signals_listbox.curselection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a signal to replay")
            return
            
        try:
            repeat_count = int(self.repeat_count_var.get())
            capture_index = selection[0]
            
            success = self.injection_engine.replay_signal(capture_index, repeat_count)
            
            if success:
                self.injection_log.insert(tk.END, f"[{datetime.now().strftime('%H:%M:%S')}] Signal replayed {repeat_count} times\n")
            else:
                self.injection_log.insert(tk.END, f"[{datetime.now().strftime('%H:%M:%S')}] Replay failed\n")
                
            self.injection_log.see(tk.END)
            
        except Exception as e:
            messagebox.showerror("Error", f"Replay failed: {str(e)}")
            
    def assess_wifi(self):
        """Perform WiFi security assessment"""
        assessment = self.security_assessor.assess_wifi_security()
        self._update_assessment_results('WiFi', assessment)
        
    def assess_bluetooth(self):
        """Perform Bluetooth security assessment"""
        assessment = self.security_assessor.assess_bluetooth_security()
        self._update_assessment_results('Bluetooth', assessment)
        
    def assess_iot(self):
        """Perform IoT security assessment"""
        frequency_ranges = [(433e6, 434e6), (2.4e9, 2.5e9), (868e6, 870e6)]
        assessment = self.security_assessor.assess_iot_security(frequency_ranges)
        self._update_assessment_results('IoT', assessment)
        
    def _update_assessment_results(self, assessment_type, assessment):
        """Update assessment results display"""
        self.assessment_results[assessment_type] = assessment
        
        # Clear existing results for this type
        for item in self.assessment_tree.get_children():
            if self.assessment_tree.item(item)['values'][0] == assessment_type:
                self.assessment_tree.delete(item)
                
        # Add new results
        if assessment_type == 'WiFi' and 'networks_found' in assessment:
            for network in assessment['networks_found']:
                for vuln in network.get('vulnerabilities', []):
                    risk_level = 'High' if 'WEP' in vuln or 'Open' in vuln else 'Medium'
                    self.assessment_tree.insert('', 'end', values=(
                        assessment_type,
                        network['ssid'],
                        risk_level,
                        vuln,
                        'Upgrade security protocol'
                    ))
                    
        elif assessment_type == 'IoT' and 'devices_detected' in assessment:
            for device in assessment['devices_detected']:
                self.assessment_tree.insert('', 'end', values=(
                    assessment_type,
                    device['device_type'],
                    device['risk_level'],
                    device['vulnerability'],
                    'Update firmware/encryption'
                ))
                
    def start_vuln_scan(self):
        """Start vulnerability scan"""
        self.vuln_progress.start()
        
        # Run vulnerability scan in background
        vuln_thread = threading.Thread(target=self._vulnerability_scan_thread)
        vuln_thread.daemon = True
        vuln_thread.start()
        
    def _vulnerability_scan_thread(self):
        """Background vulnerability scanning"""
        try:
            # Simulate vulnerability scanning
            vulnerabilities = [
                {
                    'severity': 'High',
                    'target': 'WiFi Network "OldRouter"',
                    'vulnerability': 'WEP Encryption Used',
                    'cvss': '7.5',
                    'exploit': 'Aircrack-ng',
                    'mitigation': 'Upgrade to WPA3'
                },
                {
                    'severity': 'Medium',
                    'target': 'IoT Device 433MHz',
                    'vulnerability': 'Fixed Code Transmission',
                    'cvss': '5.3',
                    'exploit': 'Signal Replay',
                    'mitigation': 'Implement rolling codes'
                },
                {
                    'severity': 'Low',
                    'target': 'Bluetooth Device',
                    'vulnerability': 'Legacy Pairing Mode',
                    'cvss': '3.1',
                    'exploit': 'PIN Brute Force',
                    'mitigation': 'Disable legacy pairing'
                }
            ]
            
            # Update GUI
            self.root.after(0, self._update_vulnerability_results, vulnerabilities)
            
        except Exception as e:
            logger.error(f"Vulnerability scan error: {e}")
        finally:
            self.root.after(0, self.vuln_progress.stop)
            
    def _update_vulnerability_results(self, vulnerabilities):
        """Update vulnerability scan results"""
        # Clear existing results
        for item in self.vuln_tree.get_children():
            self.vuln_tree.delete(item)
            
        # Add new vulnerabilities
        for vuln in vulnerabilities:
            tags = ()
            if vuln['severity'] == 'High':
                tags = ('high_severity',)
            elif vuln['severity'] == 'Medium':
                tags = ('medium_severity',)
            else:
                tags = ('low_severity',)
                
            self.vuln_tree.insert('', 'end', values=(
                vuln['severity'],
                vuln['target'],
                vuln['vulnerability'],
                vuln['cvss'],
                vuln['exploit'],
                vuln['mitigation']
            ), tags=tags)
            
        # Configure tag colors
        self.vuln_tree.tag_configure('high_severity', foreground='red')
        self.vuln_tree.tag_configure('medium_severity', foreground='orange')
        self.vuln_tree.tag_configure('low_severity', foreground='yellow')
        
    def generate_executive_summary(self):
        """Generate executive summary report"""
        report = self.security_assessor.generate_security_report(self.assessment_results)
        
        summary_text = f"""PENETRATION TESTING EXECUTIVE SUMMARY
{'='*60}

ASSESSMENT OVERVIEW:
- Assessment Date: {report['generated_at'][:10]}
- Overall Risk Level: {report['executive_summary'].get('overall_risk_level', 'Unknown')}
- Total Issues Found: {report['executive_summary'].get('total_issues_found', 0)}
- Urgent Actions Required: {'Yes' if report['executive_summary'].get('urgent_actions_required', False) else 'No'}

RISK BREAKDOWN:
- High Risk Issues: {sum(1 for item in self.vuln_tree.get_children() if self.vuln_tree.item(item)['values'][0] == 'High')}
- Medium Risk Issues: {sum(1 for item in self.vuln_tree.get_children() if self.vuln_tree.item(item)['values'][0] == 'Medium')}
- Low Risk Issues: {sum(1 for item in self.vuln_tree.get_children() if self.vuln_tree.item(item)['values'][0] == 'Low')}

KEY RECOMMENDATIONS:
"""
        
        for rec in report.get('recommendations', []):
            summary_text += f"• {rec}\n"
            
        summary_text += f"""
ASSESSMENT METHODOLOGY:
- RF Spectrum Analysis using HackRF One
- Protocol-specific vulnerability assessment
- Wireless security evaluation
- IoT device security testing

NEXT STEPS:
1. Address high-risk vulnerabilities immediately
2. Implement recommended security controls
3. Schedule follow-up assessment in 6 months
4. Provide security awareness training

Report generated by HackRF Penetration Testing Suite
Contact security team for detailed technical findings.
"""
        
        self.report_preview.delete(1.0, tk.END)
        self.report_preview.insert(1.0, summary_text)
        
    # Additional methods for other functionality...
    def stop_analysis(self):
        """Stop current analysis"""
        logger.info("Analysis stopped")
        
    def export_protocol_results(self):
        """Export protocol analysis results"""
        messagebox.showinfo("Info", "Protocol results export feature")
        
    def delete_capture(self):
        """Delete selected capture"""
        selection = self.signals_listbox.curselection()
        if selection:
            self.signals_listbox.delete(selection[0])
            
    def generate_jamming(self):
        """Generate jamming signal"""
        messagebox.showwarning("Warning", "Jamming signals are for authorized testing only!")
        
    def test_frequency_hopping(self):
        """Test frequency hopping"""
        frequencies = [433.92e6, 434.42e6, 434.92e6]
        hopping_log = self.injection_engine.test_frequency_hopping(frequencies)
        
        self.injection_log.insert(tk.END, f"[{datetime.now().strftime('%H:%M:%S')}] Frequency hopping test completed\n")
        self.injection_log.see(tk.END)
        
    def analyze_timing(self):
        """Analyze timing attacks"""
        self.injection_log.insert(tk.END, f"[{datetime.now().strftime('%H:%M:%S')}] Timing analysis started\n")
        self.injection_log.see(tk.END)
        
    def full_assessment(self):
        """Perform full security assessment"""
        self.assess_wifi()
        self.assess_bluetooth()
        self.assess_iot()
        
    def stop_vuln_scan(self):
        """Stop vulnerability scan"""
        self.vuln_progress.stop()
        
    def export_vuln_report(self):
        """Export vulnerability report"""
        messagebox.showinfo("Info", "Vulnerability report export feature")
        
    def generate_technical_report(self):
        """Generate technical report"""
        messagebox.showinfo("Info", "Technical report generation feature")
        
    def generate_compliance_report(self):
        """Generate compliance report"""
        messagebox.showinfo("Info", "Compliance report generation feature")
        
    def export_all_data(self):
        """Export all assessment data"""
        messagebox.showinfo("Info", "Data export feature")

def main():
    """Main function for HackRF Penetration Testing Suite"""
    print("HackRF Penetration Testing Suite")
    print("=" * 40)
    print("⚠️  FOR AUTHORIZED PENETRATION TESTING ONLY ⚠️")
    print("This tool is for legitimate security assessment purposes")
    print("Ensure you have proper authorization before testing")
    print("=" * 40)
    
    # Check for HackRF tools
    try:
        result = subprocess.run(['hackrf_info'], capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            print("✅ HackRF tools detected")
        else:
            print("⚠️  HackRF tools not responding")
    except:
        print("⚠️  HackRF tools not found - simulation mode active")
        
    print()
    
    # Start GUI
    root = tk.Tk()
    app = HackRFPentestGUI(root)
    
    logger.info("HackRF Penetration Testing Suite started")
    root.mainloop()

if __name__ == "__main__":
    main()