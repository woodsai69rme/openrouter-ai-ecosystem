#!/usr/bin/env python3
"""
HackRF Authorized Penetration Testing Suite
Professional RF security testing tools for authorized assessments
REQUIRES WRITTEN AUTHORIZATION BEFORE USE
"""

import os
import sys
import json
import time
import logging
import threading
import subprocess
from datetime import datetime
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox
import numpy as np
from collections import defaultdict

# WARNING: This tool is for AUTHORIZED penetration testing only
AUTHORIZATION_WARNING = """
WARNING: CRITICAL AUTHORIZATION NOTICE

This tool is designed for AUTHORIZED penetration testing and security research ONLY.

LEGAL REQUIREMENTS:
- Written authorization from network/device owners
- Compliance with local laws and regulations
- Professional penetration testing context only
- Educational/research purposes with proper oversight

PROHIBITED USES:
- Unauthorized surveillance or monitoring
- Interception of communications without consent
- Any activity violating privacy laws
- Commercial espionage or competitive intelligence

By proceeding, you confirm you have proper authorization and will use this tool
in compliance with all applicable laws and ethical guidelines.
"""

logger = logging.getLogger(__name__)

class AuthorizedPentestSuite:
    """Authorized RF penetration testing suite"""
    
    def __init__(self):
        self.version = "1.0.0"
        self.assessment_id = None
        self.authorization_confirmed = False
        self.test_modules = {
            'wifi_security': WiFiSecurityTester(),
            'bluetooth_security': BluetoothSecurityTester(),
            'iot_security': IoTSecurityTester(),
            'rf_analysis': RFAnalysisTester(),
            'protocol_analysis': ProtocolAnalysisTester()
        }
        
        # Assessment tracking
        self.assessment_log = []
        self.findings = []
        self.recommendations = []
        
    def confirm_authorization(self):
        """Confirm proper authorization before proceeding"""
        print(AUTHORIZATION_WARNING)
        print("\n" + "="*80)
        
        # Authorization checklist
        checklist = [
            "Written authorization obtained from target organization",
            "Scope of testing clearly defined and documented",
            "Legal compliance verified with counsel",
            "Test environment properly isolated",
            "Incident response plan prepared",
            "Data handling procedures established"
        ]
        
        print("AUTHORIZATION CHECKLIST:")
        for i, item in enumerate(checklist, 1):
            print(f"{i}. {item}")
        
        print("\n" + "="*80)
        
        while True:
            response = input("\nConfirm you have ALL required authorizations (yes/no): ").lower().strip()
            
            if response == 'yes':
                auth_id = input("Enter authorization ID/reference: ").strip()
                if auth_id:
                    self.authorization_confirmed = True
                    self.assessment_id = f"AUTHPEN_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{auth_id}"
                    print(f"\nAUTHORIZATION CONFIRMED. Assessment ID: {self.assessment_id}")
                    return True
                else:
                    print("ERROR: Authorization ID required")
            elif response == 'no':
                print("ERROR: Cannot proceed without proper authorization")
                return False
            else:
                print("Please enter 'yes' or 'no'")

class WiFiSecurityTester:
    """WiFi security assessment tools"""
    
    def __init__(self):
        self.scan_results = []
        self.security_issues = []
        
    def assess_wifi_security(self, target_networks=None):
        """Assess WiFi security for authorized networks"""
        
        if not target_networks:
            logger.warning("No target networks specified for assessment")
            return []
        
        findings = []
        
        for network in target_networks:
            logger.info(f"Assessing WiFi network: {network.get('ssid', 'Unknown')}")
            
            # Security configuration analysis
            security_finding = self.analyze_security_config(network)
            if security_finding:
                findings.append(security_finding)
            
            # Signal strength analysis
            signal_finding = self.analyze_signal_strength(network)
            if signal_finding:
                findings.append(signal_finding)
            
            # Encryption analysis
            encryption_finding = self.analyze_encryption(network)
            if encryption_finding:
                findings.append(encryption_finding)
        
        return findings
    
    def analyze_security_config(self, network):
        """Analyze WiFi security configuration"""
        
        security_type = network.get('security', 'Unknown')
        
        # Check for weak security configurations
        if security_type == 'Open':
            return {
                'type': 'wifi_security_weakness',
                'severity': 'high',
                'network': network['ssid'],
                'issue': 'Open network with no encryption',
                'recommendation': 'Implement WPA3 or WPA2 encryption',
                'risk': 'Unencrypted traffic can be intercepted'
            }
        
        elif security_type in ['WEP', 'WPS']:
            return {
                'type': 'wifi_security_weakness',
                'severity': 'critical',
                'network': network['ssid'],
                'issue': f'Weak security protocol: {security_type}',
                'recommendation': 'Upgrade to WPA3 or WPA2',
                'risk': 'Easily crackable encryption'
            }
        
        elif 'WPA' in security_type and 'WPA3' not in security_type:
            return {
                'type': 'wifi_security_weakness',
                'severity': 'medium',
                'network': network['ssid'],
                'issue': 'Using older WPA2 instead of WPA3',
                'recommendation': 'Upgrade to WPA3 if supported',
                'risk': 'Vulnerable to advanced attacks'
            }
        
        return None
    
    def analyze_signal_strength(self, network):
        """Analyze signal strength for security implications"""
        
        signal_strength = network.get('signal_strength', -100)
        
        # Very strong signals outside expected coverage area
        if signal_strength > -30:
            return {
                'type': 'wifi_signal_anomaly',
                'severity': 'medium',
                'network': network['ssid'],
                'issue': f'Unusually strong signal: {signal_strength} dBm',
                'recommendation': 'Verify legitimate access point location',
                'risk': 'Possible rogue access point or signal amplification'
            }
        
        return None
    
    def analyze_encryption(self, network):
        """Analyze encryption implementation"""
        
        # This would perform more detailed encryption analysis
        # For demonstration purposes, return basic check
        
        if network.get('psk_detected'):
            return {
                'type': 'wifi_encryption_issue',
                'severity': 'low',
                'network': network['ssid'],
                'issue': 'Pre-shared key detected in use',
                'recommendation': 'Consider enterprise authentication',
                'risk': 'Shared keys can be compromised'
            }
        
        return None

class BluetoothSecurityTester:
    """Bluetooth security assessment tools"""
    
    def __init__(self):
        self.discovered_devices = []
        self.security_findings = []
    
    def assess_bluetooth_security(self, target_devices=None):
        """Assess Bluetooth security for authorized devices"""
        
        findings = []
        
        if not target_devices:
            logger.warning("No target devices specified for Bluetooth assessment")
            return findings
        
        for device in target_devices:
            logger.info(f"Assessing Bluetooth device: {device.get('name', 'Unknown')}")
            
            # Device configuration analysis
            config_finding = self.analyze_device_config(device)
            if config_finding:
                findings.append(config_finding)
            
            # Service analysis
            service_finding = self.analyze_services(device)
            if service_finding:
                findings.append(service_finding)
            
            # Pairing security analysis
            pairing_finding = self.analyze_pairing_security(device)
            if pairing_finding:
                findings.append(pairing_finding)
        
        return findings
    
    def analyze_device_config(self, device):
        """Analyze Bluetooth device configuration"""
        
        # Check for discoverable mode
        if device.get('discoverable', False):
            return {
                'type': 'bluetooth_config_issue',
                'severity': 'medium',
                'device': device.get('name', 'Unknown'),
                'mac': device.get('mac', 'Unknown'),
                'issue': 'Device in discoverable mode',
                'recommendation': 'Disable discoverability when not needed',
                'risk': 'Device visible to unauthorized scanners'
            }
        
        return None
    
    def analyze_services(self, device):
        """Analyze exposed Bluetooth services"""
        
        services = device.get('services', [])
        
        # Check for potentially risky services
        risky_services = ['OBEX', 'FTP', 'DUN', 'HID']
        
        for service in services:
            if service in risky_services:
                return {
                    'type': 'bluetooth_service_risk',
                    'severity': 'medium',
                    'device': device.get('name', 'Unknown'),
                    'service': service,
                    'issue': f'Potentially risky service exposed: {service}',
                    'recommendation': 'Disable unnecessary services',
                    'risk': 'Service could be exploited for unauthorized access'
                }
        
        return None
    
    def analyze_pairing_security(self, device):
        """Analyze Bluetooth pairing security"""
        
        pairing_method = device.get('pairing_method', 'Unknown')
        
        if pairing_method == 'Just Works':
            return {
                'type': 'bluetooth_pairing_weakness',
                'severity': 'high',
                'device': device.get('name', 'Unknown'),
                'issue': 'Using "Just Works" pairing method',
                'recommendation': 'Use Numeric Comparison or Passkey Entry',
                'risk': 'Vulnerable to man-in-the-middle attacks'
            }
        
        return None

class IoTSecurityTester:
    """IoT device security assessment tools"""
    
    def __init__(self):
        self.iot_devices = []
        self.protocol_analysis = {}
    
    def assess_iot_security(self, frequency_ranges=None):
        """Assess IoT device security in specified frequency ranges"""
        
        if not frequency_ranges:
            # Default IoT frequency ranges
            frequency_ranges = [
                (433e6, 434e6, 'ISM 433MHz'),
                (868e6, 870e6, 'ISM 868MHz'),  
                (915e6, 916e6, 'ISM 915MHz'),
                (2400e6, 2485e6, 'ISM 2.4GHz')
            ]
        
        findings = []
        
        for start_freq, stop_freq, band_name in frequency_ranges:
            logger.info(f"Scanning IoT devices in {band_name}")
            
            # Simulate device discovery
            devices = self.discover_iot_devices(start_freq, stop_freq)
            
            for device in devices:
                # Analyze device security
                security_findings = self.analyze_iot_device(device, band_name)
                findings.extend(security_findings)
        
        return findings
    
    def discover_iot_devices(self, start_freq, stop_freq):
        """Discover IoT devices in frequency range"""
        
        # This would implement actual device discovery
        # For demonstration, return simulated devices
        
        simulated_devices = [
            {
                'frequency': 433.92e6,
                'protocol': 'ASK/OOK',
                'signal_strength': -45,
                'device_type': 'garage_door_opener',
                'encrypted': False
            },
            {
                'frequency': 915.5e6,
                'protocol': 'FSK',
                'signal_strength': -60,
                'device_type': 'smart_meter',
                'encrypted': True
            }
        ]
        
        return simulated_devices
    
    def analyze_iot_device(self, device, band_name):
        """Analyze individual IoT device security"""
        
        findings = []
        
        # Check encryption
        if not device.get('encrypted', True):
            findings.append({
                'type': 'iot_encryption_missing',
                'severity': 'high',
                'frequency': device['frequency'],
                'band': band_name,
                'device_type': device['device_type'],
                'issue': 'Unencrypted IoT communication detected',
                'recommendation': 'Implement encryption for device communications',
                'risk': 'Commands and data can be intercepted and replayed'
            })
        
        # Check for weak protocols
        weak_protocols = ['ASK/OOK', 'Simple FSK']
        if device.get('protocol') in weak_protocols:
            findings.append({
                'type': 'iot_protocol_weakness',
                'severity': 'medium',
                'frequency': device['frequency'],
                'protocol': device['protocol'],
                'device_type': device['device_type'],
                'issue': f'Weak protocol in use: {device["protocol"]}',
                'recommendation': 'Upgrade to more secure protocol',
                'risk': 'Protocol vulnerable to replay attacks'
            })
        
        # Check signal strength (possible jamming vulnerability)
        if device.get('signal_strength', -100) > -40:
            findings.append({
                'type': 'iot_signal_strength',
                'severity': 'low',
                'frequency': device['frequency'],
                'device_type': device['device_type'],
                'signal_strength': device['signal_strength'],
                'issue': 'Very strong signal detected',
                'recommendation': 'Verify device location and power settings',
                'risk': 'High power signals easier to jam or interfere with'
            })
        
        return findings

class RFAnalysisTester:
    """RF analysis and interference testing"""
    
    def __init__(self):
        self.spectrum_data = []
        self.interference_sources = []
    
    def analyze_rf_environment(self, frequency_ranges):
        """Analyze RF environment for security implications"""
        
        findings = []
        
        for start_freq, stop_freq, description in frequency_ranges:
            logger.info(f"Analyzing RF environment: {description}")
            
            # Spectrum analysis
            spectrum_finding = self.analyze_spectrum(start_freq, stop_freq, description)
            if spectrum_finding:
                findings.extend(spectrum_finding)
            
            # Interference detection
            interference_finding = self.detect_interference(start_freq, stop_freq, description)
            if interference_finding:
                findings.extend(interference_finding)
        
        return findings
    
    def analyze_spectrum(self, start_freq, stop_freq, description):
        """Analyze spectrum for anomalies"""
        
        findings = []
        
        # Simulate spectrum analysis
        # In real implementation, this would use actual HackRF data
        
        # Check for unusual high-power signals
        suspicious_signals = [
            {'freq': (start_freq + stop_freq) / 2, 'power': -20, 'bandwidth': 10e6}
        ]
        
        for signal in suspicious_signals:
            if signal['power'] > -30:  # Very high power
                findings.append({
                    'type': 'rf_high_power_signal',
                    'severity': 'medium',
                    'frequency': signal['freq'],
                    'power': signal['power'],
                    'bandwidth': signal['bandwidth'],
                    'description': description,
                    'issue': f'High power signal detected: {signal["power"]} dBm',
                    'recommendation': 'Investigate signal source and authorization',
                    'risk': 'Could indicate jamming or unauthorized transmission'
                })
        
        return findings
    
    def detect_interference(self, start_freq, stop_freq, description):
        """Detect RF interference patterns"""
        
        findings = []
        
        # Simulate interference detection
        # Check for wideband interference
        bandwidth_threshold = (stop_freq - start_freq) * 0.8
        
        # Simulated wideband interference
        if 'WiFi' in description:  # Example condition
            findings.append({
                'type': 'rf_interference_detected',
                'severity': 'low',
                'frequency_range': f"{start_freq/1e6:.1f} - {stop_freq/1e6:.1f} MHz",
                'description': description,
                'issue': 'Potential interference pattern detected',
                'recommendation': 'Monitor for service disruption',
                'risk': 'May affect legitimate communications'
            })
        
        return findings

class ProtocolAnalysisTester:
    """Protocol analysis for security assessment"""
    
    def __init__(self):
        self.protocol_decoders = {
            'wifi': self.analyze_wifi_protocol,
            'bluetooth': self.analyze_bluetooth_protocol,
            'zigbee': self.analyze_zigbee_protocol
        }
    
    def analyze_protocols(self, detected_protocols):
        """Analyze detected protocols for security issues"""
        
        findings = []
        
        for protocol_name, protocol_data in detected_protocols.items():
            if protocol_name in self.protocol_decoders:
                logger.info(f"Analyzing {protocol_name} protocol")
                
                protocol_findings = self.protocol_decoders[protocol_name](protocol_data)
                findings.extend(protocol_findings)
        
        return findings
    
    def analyze_wifi_protocol(self, wifi_data):
        """Analyze WiFi protocol for security issues"""
        
        findings = []
        
        # Check for deauthentication attacks
        if wifi_data.get('deauth_frames_detected', 0) > 10:
            findings.append({
                'type': 'wifi_deauth_attack',
                'severity': 'high',
                'issue': f"High number of deauthentication frames: {wifi_data['deauth_frames_detected']}",
                'recommendation': 'Investigate potential DoS attack',
                'risk': 'Clients being forcibly disconnected'
            })
        
        # Check for beacon flooding
        if wifi_data.get('beacon_rate', 0) > 100:  # beacons per second
            findings.append({
                'type': 'wifi_beacon_flood',
                'severity': 'medium',
                'issue': f"High beacon frame rate: {wifi_data['beacon_rate']}/sec",
                'recommendation': 'Check for rogue access points',
                'risk': 'Possible network confusion attack'
            })
        
        return findings
    
    def analyze_bluetooth_protocol(self, bt_data):
        """Analyze Bluetooth protocol for security issues"""
        
        findings = []
        
        # Check for inquiry flooding
        if bt_data.get('inquiry_rate', 0) > 50:
            findings.append({
                'type': 'bluetooth_inquiry_flood',
                'severity': 'medium',
                'issue': f"High inquiry rate: {bt_data['inquiry_rate']}/sec",
                'recommendation': 'Investigate scanning activity',
                'risk': 'Possible reconnaissance or DoS attack'
            })
        
        return findings
    
    def analyze_zigbee_protocol(self, zigbee_data):
        """Analyze ZigBee protocol for security issues"""
        
        findings = []
        
        # Check for network key exposure
        if zigbee_data.get('network_key_transmitted', False):
            findings.append({
                'type': 'zigbee_key_exposure',
                'severity': 'critical',
                'issue': 'ZigBee network key transmitted in clear',
                'recommendation': 'Implement proper key management',
                'risk': 'Network security completely compromised'
            })
        
        return findings

class PentestReportGenerator:
    """Generate professional penetration testing reports"""
    
    def __init__(self, assessment_id):
        self.assessment_id = assessment_id
        self.report_template = {
            'executive_summary': '',
            'methodology': '',
            'findings': [],
            'recommendations': [],
            'technical_details': '',
            'remediation_timeline': ''
        }
    
    def generate_report(self, all_findings):
        """Generate comprehensive penetration testing report"""
        
        report = {
            'assessment_id': self.assessment_id,
            'date': datetime.now().isoformat(),
            'title': 'RF Security Penetration Testing Assessment',
            'executive_summary': self.generate_executive_summary(all_findings),
            'methodology': self.get_methodology(),
            'findings': self.categorize_findings(all_findings),
            'risk_analysis': self.analyze_risk(all_findings),
            'recommendations': self.generate_recommendations(all_findings),
            'technical_appendix': self.generate_technical_details(all_findings)
        }
        
        return report
    
    def generate_executive_summary(self, findings):
        """Generate executive summary"""
        
        total_findings = len(findings)
        critical_findings = len([f for f in findings if f.get('severity') == 'critical'])
        high_findings = len([f for f in findings if f.get('severity') == 'high'])
        
        summary = f"""
RF Security Assessment Executive Summary

This assessment evaluated the radio frequency (RF) security posture of the authorized 
target environment. A total of {total_findings} security findings were identified, 
including {critical_findings} critical and {high_findings} high severity issues.

Key areas of concern include wireless network security, IoT device configurations, 
and RF protocol implementations. Immediate attention is required for critical 
findings to prevent potential security breaches.
"""
        
        return summary.strip()
    
    def get_methodology(self):
        """Get assessment methodology"""
        
        return """
Assessment Methodology:

1. RF Environment Survey
   - Spectrum analysis across relevant frequency bands
   - Device discovery and enumeration
   - Signal strength and coverage mapping

2. Wireless Network Security Testing
   - WiFi security configuration assessment
   - Bluetooth device security evaluation
   - IoT protocol analysis

3. Protocol Security Analysis
   - Frame analysis and decoding
   - Encryption implementation review
   - Authentication mechanism testing

4. Interference and Jamming Assessment
   - RF interference pattern detection
   - Jamming vulnerability evaluation
   - Signal integrity analysis

All testing was conducted with proper authorization and in compliance with 
applicable laws and regulations.
"""
    
    def categorize_findings(self, findings):
        """Categorize findings by type and severity"""
        
        categorized = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }
        
        for finding in findings:
            severity = finding.get('severity', 'low')
            if severity in categorized:
                categorized[severity].append(finding)
        
        return categorized
    
    def analyze_risk(self, findings):
        """Analyze overall risk"""
        
        risk_scores = {'critical': 4, 'high': 3, 'medium': 2, 'low': 1}
        
        total_score = sum(risk_scores.get(f.get('severity', 'low'), 1) for f in findings)
        max_possible = len(findings) * 4
        
        risk_percentage = (total_score / max(max_possible, 1)) * 100
        
        if risk_percentage > 75:
            risk_level = 'CRITICAL'
        elif risk_percentage > 50:
            risk_level = 'HIGH'
        elif risk_percentage > 25:
            risk_level = 'MEDIUM'
        else:
            risk_level = 'LOW'
        
        return {
            'overall_risk': risk_level,
            'risk_score': total_score,
            'risk_percentage': risk_percentage
        }
    
    def generate_recommendations(self, findings):
        """Generate prioritized recommendations"""
        
        recommendations = []
        
        # Group recommendations by type
        rec_groups = defaultdict(list)
        
        for finding in findings:
            rec = finding.get('recommendation', '')
            if rec:
                severity = finding.get('severity', 'low')
                rec_groups[severity].append(rec)
        
        # Prioritize by severity
        for severity in ['critical', 'high', 'medium', 'low']:
            if severity in rec_groups:
                unique_recs = list(set(rec_groups[severity]))
                for rec in unique_recs:
                    recommendations.append({
                        'priority': severity.upper(),
                        'recommendation': rec,
                        'timeline': self.get_timeline(severity)
                    })
        
        return recommendations
    
    def get_timeline(self, severity):
        """Get recommended timeline for remediation"""
        
        timelines = {
            'critical': 'Immediate (within 24 hours)',
            'high': 'Urgent (within 1 week)',
            'medium': 'Short term (within 1 month)',
            'low': 'Long term (within 3 months)'
        }
        
        return timelines.get(severity, 'As resources permit')
    
    def generate_technical_details(self, findings):
        """Generate technical appendix"""
        
        details = "Technical Details\n\n"
        
        for i, finding in enumerate(findings, 1):
            details += f"Finding {i}: {finding.get('type', 'Unknown')}\n"
            details += f"Severity: {finding.get('severity', 'Unknown')}\n"
            details += f"Issue: {finding.get('issue', 'No description')}\n"
            details += f"Risk: {finding.get('risk', 'Unknown risk')}\n"
            details += f"Recommendation: {finding.get('recommendation', 'No recommendation')}\n"
            details += "-" * 50 + "\n"
        
        return details

def main():
    """Main function for authorized penetration testing suite"""
    
    print("HackRF Authorized Penetration Testing Suite")
    print("=" * 60)
    
    # Initialize suite
    suite = AuthorizedPentestSuite()
    
    # Confirm authorization
    if not suite.confirm_authorization():
        print("Exiting: Authorization not confirmed")
        return
    
    print(f"\nSTARTING AUTHORIZED ASSESSMENT: {suite.assessment_id}")
    
    # Example assessment workflow
    all_findings = []
    
    # WiFi Security Assessment
    wifi_networks = [
        {'ssid': 'TestNetwork', 'security': 'WPA2', 'signal_strength': -45},
        {'ssid': 'UnsecureAP', 'security': 'Open', 'signal_strength': -30}
    ]
    
    wifi_findings = suite.test_modules['wifi_security'].assess_wifi_security(wifi_networks)
    all_findings.extend(wifi_findings)
    
    # IoT Security Assessment
    iot_findings = suite.test_modules['iot_security'].assess_iot_security()
    all_findings.extend(iot_findings)
    
    # RF Analysis
    rf_ranges = [
        (2400e6, 2485e6, 'WiFi 2.4GHz'),
        (433e6, 434e6, 'IoT 433MHz')
    ]
    
    rf_findings = suite.test_modules['rf_analysis'].analyze_rf_environment(rf_ranges)
    all_findings.extend(rf_findings)
    
    # Generate report
    reporter = PentestReportGenerator(suite.assessment_id)
    report = reporter.generate_report(all_findings)
    
    # Save report
    report_filename = f"pentest_report_{suite.assessment_id}.json"
    with open(report_filename, 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"\nASSESSMENT COMPLETED. Report saved: {report_filename}")
    print(f"Total findings: {len(all_findings)}")
    
    # Display summary
    risk_analysis = report['risk_analysis']
    print(f"Overall risk level: {risk_analysis['overall_risk']}")
    print(f"Risk score: {risk_analysis['risk_score']}")

if __name__ == "__main__":
    main()